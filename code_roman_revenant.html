<!DOCTYPE html>
<html lang="en">
  <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>Code_Roman_Revenant</title>
        <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />
        <!-- Font Awesome icons (free version)-->
        <script src="https://use.fontawesome.com/releases/v6.3.0/js/all.js" crossorigin="anonymous"></script>
        <!-- Google fonts-->
        <link href="https://fonts.googleapis.com/css?family=Varela+Round" rel="stylesheet" />
        <link href="https://fonts.googleapis.com/css?family=Nunito:200,200i,300,300i,400,400i,600,600i,700,700i,800,800i,900,900i" rel="stylesheet" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="css/styles.css" rel="stylesheet" />
        <title>Code_Roman_Revenant</title>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/atom-one-dark.min.css">
  </head>
  <body id="page-top">
        <!-- Navigation-->
        <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
            <div class="container px-4 px-lg-5">
                <a class="navbar-brand" href="index.html">Main page</a>
                <button class="navbar-toggler navbar-toggler-right" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                    Menu
                    <i class="fas fa-bars"></i>
                </button>
                <div class="collapse navbar-collapse" id="navbarResponsive">
                    <ul class="navbar-nav ms-auto">
                        <li class="nav-item"><a class="nav-link" href="roman_revenant.html">Project Page</a></li>
                        <li class="nav-item"><a class="nav-link" href="code_roman_revenant.html">Code Page</a></li>
                        <div class="dropdown">
                            <button onclick="myFunction()" class="dropbtn"><img src="./assets/img/Hamburger_icon.png" height="20px"></button>
                            <div id="myDropdown" class="dropdown-content">
                              <a href="roman_revenant.html">Roman Revenant</a>
                              <a href="yoshi.html">Yoshi's Skyward Soar</a>
                              <a href="tokyo_glow.html">Tokyo Glow</a>
                              <a href="dinobot.html">Dinobot</a>
                              <a href="piggies_adventure.html">Piggies Adventure</a></br>
                              <a href="code_roman_revenant.html">Code Roman Revenant</a>
                              <a href="code_yoshi.html">Code Yoshi's Skyward Soar</a>
                              <a href="code_tokyo_glow.html">Code Tokyo Glow</a>
                              <a href="code_dinobot.html">Code Dinobot</a>
                              <a href="code_piggies_adventure.html">Code Piggies Adventure</a>
                            </div>
                        </div>
                    </ul>
                </div>
            </div>
        </nav>
        <!-- Masthead-->
        <header class="masthead">
            <div class="container px-lg-5 d-flex h-75 align-items-center justify-content-center">
                <div class="d-flex justify-content-center">
                    <div class="text-center">
                        <h1 class="mx-auto my-0 text-uppercase">Code Roman Revenant</h1>
                        <!--h6 class="mx-auto my-0 text-uppercase">!Work In Progress!</h6-->
                    </div>
                </div>
            </div>
        </header>
        <div class="container col-lg-7 horizontal-line-custom"></div>
        <!-- Code-->
        <div class="container px-8 px-lg-10">
            <div class="row gx-4 gx-lg-5 justify-content-center">
                <div class="col-lg-8 col-lg-8 d-flex flex-row flex-wrap align-self-center align-items-center">
                    <div class="own-column">
                        <div class="own-code">
                            <pre>
                                <code>
public enum States
{
    chasePlayer,
    chaseNewPos,
    attack,
    abilityUse
}
                                </code>
                            </pre>
                        </div>
                    </div>
                    <div class="own-column own-text">
                        This enum has all the possible states the enemy can be in. 
                        They are in order from top to bottom, with the top having the least priority and the bottom having the most priority.
                    </div>
                    <div class="own-space-between"></div>
                    <div class="own-column">
                        <div class="own-code">
                            <pre>
                                <code>
//Making an reference to the enum
[SerializeField] States currentState;
private States defaultState;


private void Start()
{
    defaultState = States.chasePlayer;
    currentState = defaultState;
}
                                </code>
                            </pre>
                        </div>
                    </div>
                    <div class="own-column">
                        <div class="own-column-img">
                            <video autoplay muted loop height="400px" class="img-fluid d-flex justify-content-center">
                                <source src="assets/video/Roman_Revenant_ClipOne.mp4" type="video/mp4" />
                            </video>
                        </div>
                        <div class="own-text">
                            The default state of the enemies. Chasing the player! 
                            If there is no other state that wants to be activated or if it is done with the other state, it goes to this state.
                        </div>
                    </div>
                    <div class="own-column">
                        <div class="own-code">
                            <pre>
                                <code>
public void TriggerChaseNewPos()
{
    newPosTimer += Time.deltaTime;
    distanceToNewPos = Vector3.Distance
    (newPos, enemyNewPosGen.transform.position);

    //If the "ping" goes off
    if (newPosTimer &gt;= randomTime)
    {
        WantsToBeNextState(States.chaseNewPos);
    }

    //If the new target has been reached, reset timers and state
    if (currentState == States.chaseNewPos &amp;&amp; distanceToNewPos &lt; 1)
    {
        ResetTimers();
        GoToDefaultState();
    }
}

//Priority check
private void WantsToBeNextState(States possableNewState)
{
    if (currentState &lt; possableNewState)
    {
        GoToNextState(possableNewState);
    }
}

//It becomes the new state
private void GoToNextState(States newState)
{
    currentState = newState;
}
                                </code>
                            </pre>
                        </div>
                    </div>
                    <div class="own-column">
                        <div class="own-column-img">
                            <video autoplay muted loop height="400px" class="img-fluid d-flex justify-content-center">
                                <source src="assets/video/Roman_Revenant_ClipTwo.mp4" type="video/mp4" />
                            </video>
                        </div></br>
                        <div class="own-text">
                            The second state that the enemy can go to, is the new pos state. 
                            How it works: randomly there goes a timer off, and the code gives sort of a ping which is like "Hey, I want to be the main state now".
                            After that ping, it goes through a priority check if the "ping" state is a higher priority than the current state. If it is, it becomes that state.
                        </br></br>
                            For the other state, ability use, It works the same as the new pos state. But for the other state, the attack state, its "ping" works differently.
                            The attack state gives a ping if the enemy is within range of the player.
                        </div>
                    </div>
                    <div class="own-column">
                        <div class="own-code">
                            <pre>
                                <code>
private void StateInfo()
{
    if (currentState == States.chasePlayer)
    {
        //The enemy is chasing the player
        enemy.enemyAgent.destination = playerTransform.transform.position;
    }
    if (currentState == States.chaseNewPos &amp;&amp; !newPosAlreadyCalledOnce)
    {
        /*Function get called for generating new position
        After that the enemy is chasing that new position (new pos)*/
        newPosAlreadyCalledOnce = true;
        newPos = enemyNewPosGen.CreateNewPos();
        enemy.enemyAgent.destination = newPos;
    }
    if (currentState == States.attack &amp;&amp; !attackAlreadyCalledOnce)
    {
        //Function get called for attacking the player
        attackAlreadyCalledOnce = true;
        enemy.enemyAgent.speed = 0f;
        enemyMainAttack.CheckForDesync();
    }
    if (currentState != States.attack &amp;&amp; 
    currentState != States.abilityUse &amp;&amp; !enemy.isDead)
    {
        //Resetting the attack and speed
        enemy.canAttackPlayer = false;
        enemy.enemyAgent.speed = enemy.enemySpeed;
    }
    if (currentState == States.abilityUse &amp;&amp; !abilityUseAlreadyCalledOnce)
    {
        abilityUseAlreadyCalledOnce = true;
        //Checking if the enemy has an ability
        if (enemy.data.Ability == EnemyAbilities.none)
        {
            GoToDefaultState();
            ResetTimers();
            return;
        }
        //If he has, call function to activate the ability
        enemy.enemyAgent.speed = 0;
        StartCoroutine(enemyAbility.DoAbilityAnimation());
    }
}
                                </code>
                            </pre>
                        </div>
                    </div>
                    <div class="own-column">
                        <!--div class="own-column-img">
                            <video autoplay muted loop height="400px" class="img-fluid d-flex justify-content-center">
                                <source src="assets/video/Roman_Revenant_ClipOne.mp4" type="video/mp4" />
                            </video>
                        </div-->
                        <div class="own-text">
                            This function manages what is going to happen if it's in a certain state. 
                            I only want the function to be called once in the if statement, so that's why there is a "! -any state- AlreadyCalledOnce" and the end of all the if statements
                            and a "= true" in the first line in the if statements.
                        </div>
                    </div>
                    <div class="own-column">
                        <div>
                            Results:
                        </div>
                        <video autoplay muted loop height="400px" class="img-fluid d-flex justify-content-center">
                            <source src="assets/video/Roman_Revenant_ClipThree.mp4" type="video/mp4" />
                        </video>
                    </div>
                </div>
            </div>
        </div>
        <section class="about-section-custom" id="Piggies Adventure Code">
            <div class="container px-8 px-lg-10">
                <div class="row gx-4 gx-lg-5 justify-content-center">
                    <div class="col-lg-8">
                        <h3 class="text-white text-center">
                            The Full Script </br>
                            |</br>
                            v
                        </h3></br>
                        <button type="button" class="own-collapsible">StateMachine.cs</button>
                        <div class="own-content">
                            <pre>
                                <code>
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using UnityEngine;

public enum States
{
    chasePlayer,
    chaseNewPos,
    attack,
    abilityUse
}

public class StateMachine : MonoBehaviour
{
    [HideInInspector] public GameObject playerTransform;

    //Making an reference to the enum
    [SerializeField] States currentState;
    private States defaultState;

    [SerializeField] float abilityTimer;
    private float randomTime;
    private float newPosTimer;

    private bool newPosAlreadyCalledOnce;
    private bool attackAlreadyCalledOnce;
    private bool abilityUseAlreadyCalledOnce;


    private Vector3 newPos;
    private float distanceToNewPos;

    private EnemyNewPosGeneration enemyNewPosGen;
    private Enemy enemy;
    private EnemyAbility enemyAbility;
    private EnemyMainAttack enemyMainAttack;

    private void Start()
    {
        defaultState = States.chasePlayer;
        currentState = defaultState;
        randomTime = UnityEngine.Random.Range(1, 10);

        enemyNewPosGen = GetComponent&lt;EnemyNewPosGeneration&gt;();
        enemy = GetComponent&lt;Enemy&gt;();
        enemyAbility = GetComponent&lt;EnemyAbility&gt;();
        enemyMainAttack = GetComponent&lt;EnemyMainAttack&gt;();
    }

    private void Update()
    {
        if (enemy == null)
        {
            return;
        }
        if (playerTransform == null)
        {
            playerTransform = GameObject.FindWithTag(&quot;Player&quot;);
        }
        StateInfo();
        TriggerChaseNewPos();
        TriggerAbilityUse();
        TriggerAttack();
    }

    public void TriggerChaseNewPos()
    {
        newPosTimer += Time.deltaTime;
        distanceToNewPos = Vector3.Distance
        (newPos, enemyNewPosGen.transform.position);

        //If the "ping" goes off
        if (newPosTimer &gt;= randomTime)
        {
            WantsToBeNextState(States.chaseNewPos);
        }

        //If the new target has been reached, reset timers and state
        if (currentState == States.chaseNewPos &amp;&amp; distanceToNewPos &lt; 1)
        {
            ResetTimers();
            GoToDefaultState();
        }
    }

    public void TriggerAttack()
    {
        float distance = Vector3.Distance
        (playerTransform.transform.position, transform.position);

        //If the player is in range
        if (distance &lt; enemy.attackRange)
        {
            WantsToBeNextState(States.attack);
        }

        //If the player is not in range, reset to default state
        else if (currentState == States.attack)
        {
            currentState = defaultState;
        }
    }

    private void TriggerAbilityUse()
    {
        abilityTimer += Time.deltaTime;

        //If the "ping" goes off
        if (abilityTimer &gt;= enemy.abilityCooldown)
        {
            WantsToBeNextState(States.abilityUse);
        }

        if (currentState == States.abilityUse &amp;&amp; enemyAbility.EndAbility)
        {
            ResetTimers();
            GoToDefaultState();
            enemyAbility.EndAbility = false;
        }
    }

    //Priority check
    private void WantsToBeNextState(States possableNewState)
    {
        if (currentState &lt; possableNewState)
        {
            GoToNextState(possableNewState);
        }
    }

    //It becomes the new state
    private void GoToNextState(States newState)
    {
        currentState = newState;
    }

    //All info what all the states do
    private void StateInfo()
    {
        if (currentState == States.chasePlayer)
        {
            //The enemy is chasing the player
            enemy.enemyAgent.destination = playerTransform.transform.position;
        }
        if (currentState == States.chaseNewPos &amp;&amp; !newPosAlreadyCalledOnce)
        {
            /*Function get called for generating new position
            After that the enemy is chasing that new position (new pos)*/
            newPosAlreadyCalledOnce = true;
            newPos = enemyNewPosGen.CreateNewPos();
            enemy.enemyAgent.destination = newPos;
        }
        if (currentState == States.attack &amp;&amp; !attackAlreadyCalledOnce)
        {
            //Function get called for attacking the player
            attackAlreadyCalledOnce = true;
            enemy.enemyAgent.speed = 0f;
            enemyMainAttack.CheckForDesync();
        }
        if (currentState != States.attack &amp;&amp; 
        currentState != States.abilityUse &amp;&amp; !enemy.isDead)
        {
            //Resetting the attack and speed
            enemy.canAttackPlayer = false;
            enemy.enemyAgent.speed = enemy.enemySpeed;
        }
        if (currentState == States.abilityUse &amp;&amp; !abilityUseAlreadyCalledOnce)
        {
            abilityUseAlreadyCalledOnce = true;

            //Checking if the enemy has an ability
            if (enemy.data.Ability == EnemyAbilities.none)
            {
                GoToDefaultState();
                ResetTimers();
                return;
            }

            //If he has, call function to activate the ability
            enemy.enemyAgent.speed = 0;
            StartCoroutine(enemyAbility.DoAbilityAnimation());
        }
    }

    //Reset to the default state (chasing the player)
    public void GoToDefaultState()
    {
        currentState = defaultState;
        newPosAlreadyCalledOnce = false;
        attackAlreadyCalledOnce = false;
        abilityUseAlreadyCalledOnce = false;
    }

    //Resetting all timers
    public void ResetTimers()
    {
        newPosTimer = 0;
        randomTime = UnityEngine.Random.Range(1, 10);
        abilityTimer = 0;
    }
}
                                </code>
                            </pre>
                        </div>
                        <!--div class="padding-custom-4"></div>
                        <button type="button" class="own-collapsible">Enemy.cs</button>
                        <div class="own-content">
                            <pre>
                                <code>
using System.Collections;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEngine;
using UnityEngine.AI;

public class Enemy : MonoBehaviour
{
    public EnemyData data;

    public AnimationClip dieAnimation;

    [HideInInspector] public string nameOfEnemy;
    [HideInInspector] public float damageAmount;
    [HideInInspector] public float enemySpeed;
    [HideInInspector] public float timeBetweenAttacks;
    [HideInInspector] public float timeTillHit;
    [HideInInspector] public float accuracyEnemy;
    [HideInInspector] public float attackRange;

    [HideInInspector] public float passiveCritChance;

    [HideInInspector] public float abilityCooldown;

    [HideInInspector] public float selfHealAmount;

    [HideInInspector] public float aoeAbilityHealAmount;
    [HideInInspector] public float aoeAbilityHealRange;

    [HideInInspector] public float enemyBuffChance;

    [HideInInspector] public NavMeshAgent enemyAgent;

    [HideInInspector] public bool canAttackPlayer;
    [HideInInspector] public bool onAttackCooldown;

    [HideInInspector] public bool isDead;

    [HideInInspector] public bool isInRange;

    [HideInInspector] public Animator animator;

    [SerializeField] private ParticleSystem bloodParticle;

    [HideInInspector] public float enemyMaxHealth;

    private AudioSource deathnoise;
    private bool playOnce;

    public float enemyHealth;
    private void Awake()
    {
        nameOfEnemy = data.EnemyName;
        enemyMaxHealth = data.MaxHealth;
        enemyHealth = enemyMaxHealth;
        damageAmount = data.Damage;
        enemySpeed = data.Speed;
        timeBetweenAttacks = data.AttackFrequency;
        timeTillHit = data.TimeTillAnimationHit;
        accuracyEnemy = data.Accuracy;
        attackRange = data.Range;

        passiveCritChance = data.CritChance;

        abilityCooldown = data.Cooldown;

        selfHealAmount = data.HealAmount;
        aoeAbilityHealAmount = data.AoeHealAmount;
        aoeAbilityHealRange = data.AoeHealRange;

        enemyBuffChance = data.BuffChance;

        animator = GetComponent&lt;Animator&gt;();
        enemyAgent = GetComponent&lt;NavMeshAgent&gt;();
    }

    public void Heal(float heal)
    {
        enemyHealth += heal;
    }

    public void TakeDamage(float damage)
    {
        bloodParticle.Play();
        enemyHealth -= damage;
        SoundSystem.Instance.SwingHit();
        if (enemyHealth &lt;= 0)
        {
            
            StartCoroutine(DieAnimation());
        }
    }

    private IEnumerator DieAnimation()
    {
        isDead = true;
        if (!playOnce) 
        {
            deathnoise = GetComponent&lt;AudioSource&gt;();
            deathnoise.Play();
            playOnce = true;
        }
        animator.SetInteger(&quot;Death&quot;, Random.Range(1, 2));
        damageAmount = 0;
        enemyAgent.speed = 0;
        GetComponent&lt;EnemyBuff&gt;().buffedEnemyCanvas.SetActive(false);
        yield return new WaitForSeconds(dieAnimation.length);
        Die();
    }
    private void Die()
    {
        var playerScoreAndMoney = FloatValueManager.Instance;
        playerScoreAndMoney.CurrentScore += data.ScoreGiven;
        playerScoreAndMoney.CurrentGold += data.GoldGiven;

        Destroy(gameObject);
    }
}

                                </code>
                            </pre>
                        </div-->
                        <!--div class="padding-custom-4"></div>
                        <button type="button" class="own-collapsible">EnemyMainAttack.cs</button>
                        <div class="own-content">
                        <pre>
                            <code>
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public enum MainAttacks
{
    stab,
    slash,
    shoot,
    snipe
}

public enum Sniper
{
    scope,
    fire
}
public class EnemyMainAttack : MonoBehaviour
{
    [SerializeField] GameObject hitRange;
    [SerializeField] GameObject fireball;

    [SerializeField] Collider enemyHitRange;

    private Enemy enemy;
    private StateMachine stateMachine;
    private LazerForSniper lazerForSniper;

    private Sniper sniper;

    private bool isOnAttackCooldown;

    private GameObject currentHitRange;
    private GameObject currentFireball;

    private HitRangeCollider hitRangeCollider;

    private float angle;

    public bool canTurnToPlayer;
    public bool canTurnToPredict;
    private void Awake()
    {
        enemy = GetComponent&lt;Enemy&gt;();
        stateMachine = GetComponent&lt;StateMachine&gt;();
        lazerForSniper = GetComponentInChildren&lt;LazerForSniper&gt;();

        hitRangeCollider = GetComponentInChildren&lt;HitRangeCollider&gt;();
    }

    private void Update()
    {
        if (currentFireball != null)
        {
            currentFireball.transform.position -= new Vector3(0, 8 * Time.deltaTime, 0);
        }
        if (angle &gt; 1f &amp;&amp; sniper == Sniper.scope &amp;&amp; canTurnToPlayer)
        {
            // Rotate towards the player
            Vector3 direction = (stateMachine.playerTransform.transform.position - transform.position).normalized;
            Quaternion lookRotation = Quaternion.LookRotation(direction, Vector3.up);
            transform.rotation = Quaternion.Lerp(transform.rotation, lookRotation, 5f * Time.deltaTime);
        }
        if (angle &gt; 1f &amp;&amp; sniper == Sniper.scope &amp;&amp; canTurnToPredict)
        {
            // Rotate towards the player
            Vector3 direction = (lazerForSniper.predictPlayerPosition - transform.position).normalized;
            Quaternion lookRotation = Quaternion.LookRotation(direction, Vector3.up);
            transform.rotation = Quaternion.Lerp(transform.rotation, lookRotation, 5f * Time.deltaTime);
        }
    }
    public void CheckForDesync()
    {
        float number = Random.Range(1, 100);
        if (number &lt; enemy.accuracyEnemy &amp;&amp; !isOnAttackCooldown)
        {
            enemy.animator.SetBool(&quot;Attack&quot;, true);
            StartCoroutine(AttackCooldown());
            StartCoroutine(DesyncAttackAnimation());
        }
        else if (!isOnAttackCooldown)
        {
            enemy.animator.SetBool(&quot;AttackMiss&quot;, true);
        }
    }

    private IEnumerator DesyncAttackAnimation()
    {
        if (enemy.data.MainAttack == MainAttacks.shoot)
        {
            currentHitRange = Instantiate(hitRange, stateMachine.playerTransform.transform.position,
                stateMachine.playerTransform.transform.rotation);
            yield return new WaitForSeconds(enemy.timeTillHit);

            currentFireball = Instantiate(fireball, currentHitRange.transform.position +
                new Vector3(Random.Range(-2.5f, 2.5f), 10, Random.Range(-2.5f, 2.5f)), transform.rotation);
            Destroy(currentHitRange);
            yield return new WaitForSeconds(1.5f);

            Destroy(currentFireball);
        }
        if (enemy.data.MainAttack == MainAttacks.snipe)
        {
            canTurnToPlayer = true;
            angle = Vector3.Angle(transform.forward, stateMachine.playerTransform.transform.position - transform.position);
            StartCoroutine(GetComponentInChildren&lt;LazerForSniper&gt;().GetAndSetAllPositions());
        }
        else
        {
            yield return new WaitForSeconds(enemy.timeTillHit);
            InColliderRange();
        }
    }

    private void InColliderRange()
    {
        if (enemyHitRange.bounds.Contains(stateMachine.playerTransform.transform.position) &amp;&amp; 
            enemy.data.Passives == Passives.crit)
        {
            float number = Random.Range(1, 100);
            if (number &lt; enemy.passiveCritChance)
            {
                PlayerHealth player = hitRangeCollider.otherCollider.GetComponent&lt;PlayerHealth&gt;();
                player.TakeDamage(enemy.damageAmount * Random.Range(2.8f, 3.1f));
            }
            else
            {
                PlayerHealth player = hitRangeCollider.otherCollider.GetComponent&lt;PlayerHealth&gt;();
                player.TakeDamage(enemy.damageAmount);
            }
        }
        if (enemyHitRange.bounds.Contains(stateMachine.playerTransform.transform.position) &amp;&amp;
            enemy.data.Passives != Passives.crit)
        {
            PlayerHealth player = hitRangeCollider.otherCollider.GetComponent&lt;PlayerHealth&gt;();
            player.TakeDamage(enemy.damageAmount);
        }
    }

    private IEnumerator AttackCooldown()
    {
        isOnAttackCooldown = true;
        yield return new WaitForSeconds(enemy.timeBetweenAttacks);
        enemy.animator.SetBool(&quot;Attack&quot;, false);
        enemy.animator.SetBool(&quot;AttackMiss&quot;, false);
        stateMachine.GoToDefaultState();
        stateMachine.ResetTimers();
        isOnAttackCooldown = false;
    }
}
                            </code>
                        </pre>
                        </div-->
                        <div class="padding-custom-2"></div>
                        <div class="text-center">
                            <h2 class="text-white-50 mx-auto mt-6 mb-2">Go back</h2>
                            <a class="btn btn-primary" href="roman_revenant.html">Roman Revenant</a>
                            <h2 class="text-white-50 mx-auto mt-3 mb-2">or</h2>
                            <a class="btn btn-primary" href="index.html#projects">Home Page</a>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        <section class="padding-under-custom"></section>  
        <!-- Footer-->
        <!-- Core theme JS-->
        <script src="js/scripts.js"></script>
        <!-- Bootstrap core JS-->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
        <script>
var coll = document.getElementsByClassName("own-collapsible");
var i;

for (i = 0; i < coll.length; i++) {
  coll[i].addEventListener("click", function() {
    this.classList.toggle("own-active");
    var content = this.nextElementSibling;

    if (!content.style.display || content.style.display === "block") {
      content.style.display = "none";
    } else {
      content.style.display = "block";
    }
  });
}
            </script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
  </body>
</html>